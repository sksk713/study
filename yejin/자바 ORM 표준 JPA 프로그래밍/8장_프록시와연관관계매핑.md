## 프록시

### 프록시 객체

조회를 지연시키는 가짜 객체, 실제 객체에 대한 참조 보관

- 처음 사용할 때 한 번만 초기화

- 초기화 후 프록시 객체를 통해서 실제 엔티티에 접근

- 프록시 객체에서 식별자 값을 조회

  ```java
  Team team = em.getReference(Team.class, "team1");  // 식별자 보관
  team.getId();  // 초기화?
  ```

  - 엔티티 접근 방식을 프로퍼티로 설정한 경우 - 초기화하지 않음
  - 엔티티 접근 방식을 필드로 설정한 경우 - 초기화

### 즉시 로딩과 지연 로딩

- 즉시 로딩 : 엔티티를 조회할 때 연관된 엔티티도 함께 조회

  - 연관된 엔티티를 즉시 조회. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회

  <aside>
  💡 nullable 설정에 따른 조인 전략
  - @JoinColumn(nullable=true) : NULL 허용(기본값), 외부 조인 사용
  - @JoinColumn(nullable=false) : NULL 허용하지 않음, 내부 조인 사용


  외부 조인보다 내부 조인이 성능 최적화에 유리하다. 외래 키에 NULL 값을 허용하지 않는다면 @JoinColumn(nullable=false)로 설정하자

  </aside>

- 지연 로딩 : 연관된 엔티티를 실제 사용할 때 조회 (엔티티가 실제 사용될 때까지 데이터베이스 조회 지연)

  - 연관된 엔티티를 프록시로 조회. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다.

  ```java
  Member member = em.find(Member.class, "member1");
  Team team = member.getTeam();  // 프록시 객체
  team.getName();  // 팀 객체 실제 사용 (프록시 객체 초기화)
  ```

- JPA 기본 페치 전략

  - `@ManyToOne`, `@OneToOne` : 즉시 로딩
  - `@OneToMany`, `@ManyToMany` : 지연 로딩
  - 모든 연관관계에 지연 로딩 사용 추천, 필요한 곳에만 즉시 로딩을 사용하도록 최적화

<br>
<br>


## 영속성 전이: CASCADE

특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만듦

- 연관관계 매핑과 관련 없음
- 엔티티를 영속화활 때 연관된 엔티티도 같이 영속화하는 편리함 제공

### 저장

영속성 사용 X

```java
Parent parent = new Parent();
em.persist(parent);

Child child1 = new Child();
child1.setParent(parent);  
parent.getChildren().add(child1);
em.persist(child1)

Child child2 = new Child();
child2.setParent(parent);  
parent.getChildren().add(child2);
em.persist(child2)
```

영속성 사용 O

```java
@Entity
public class Parent {
		
		@OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)
		private List<Child> children = new ArrayList<>();
}
```

```java
Parent parent = new Parent();

Child child1 = new Child();
child1.setParent(parent);  
parent.getChildren().add(child1);

Child child2 = new Child();
child2.setParent(parent);  
parent.getChildren().add(child2);

em.persist(parent);
```

### 삭제

영속성 사용 X

```java
Parent findParent = em.find(Parent.class, 1L);
Child findChild1 = em.find(Child.class, 1L);
Child findChild2 = em.find(Child.class, 2L);

em.remove(findParent);
em.remove(findChild1);
em.remove(findChild2);
```

영속성 사용 O

```java
Parent findParent = em.find(Parent.class, 1L);
Child findChild1 = em.find(Child.class, 1L);
Child findChild2 = em.find(Child.class, 2L);

em.remove(findParent);
```

<br>
<br>

## 고아 객체 제거

부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능

```java
@OneToMany(mappedBy = "parent", orphanRemoval = true)
private List<Child> children = new ArrayList<>();
```

