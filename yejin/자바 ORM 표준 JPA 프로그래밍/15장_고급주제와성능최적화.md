## 예외 처리

### 1. JPA 표준 예외 정리

JPA 표준 예외들은 `PersistenceException` , `RuntimeException` 의 자식 클래스

- 트랜잭션 롤백을 표시하는 예외
  - 심각한 예외이므로 복구하면 안됨. 트랜잭션을 강제로 커밋해도 커밋되지 않음
- 트랜잭션 롤백을 표시하지 않는 예외
  - 트랜잭션을 커밋할지 롤백할지 판단하여 처리

### 2. 스프링 프레임워크의 JPA 예외 변환

서비스 계층에서 JPA의 의존을 막기 위해 데이터 접근 계층에 대한 예외를 추상화해서 제공

### 3. 스프링 프레임워크에 JPA 예외 변환기 적용

JPA 예외를 스프링 프레임워크가 제공하는 추상화된 예외로 변경하려면 `PersistenceExceptionTranslationPostProcessor`를 스프링 빈으로 등록.

`@Repository` 어노테이션을 사용한 곳에 예외 변환 AOP를 적용해서 JPA 예외를 스프링 프레임워크가 추상화환 예외로 변환

### 4. 트랜잭션 롤백 시 주의사항

트랜잭션을 롤백하면 데이터베이스의 데이터는 원래대로 복구되지만 객체는 수정된 상태로 영속성 컨텍스트에 남아 있음

⇒ 새로운 영속성 컨텍스트를 생성해서 사용하거나 EntityManager.clear()를 사용하여 영속성 컨텍스트를 초기화한 후 사용


<br>
<br>

## 엔티티 비교

**1차 캐시**

영속성 컨텍스트 내부에는 엔티티 인스턴스를 보관하기 위한 1차 캐시 존재. 1차 캐시의 생명주기는 영속성 컨텍스트와 같음

영속성 컨텍스트를 통해 데이터를 저장하거나 조회하면 1차 캐시에 `엔티티가 저장`됨. `변경 감지 기능 동작`, `데이터 바로 조회`

### 1. 영속성 컨텍스트가 같을 때 엔티티 비교

영속성 컨텍스트가 같으면 엔티티를 비교할 때 다음 3가지 조건을 모두 만족

- 동일성 : == 비교가 같다.
- 동등성 : equals() 비교가 같다.
- 데이터베이스 동등성 : @Id인 데이터베이스 식별자가 같다.

### 2. 영속성 컨텍스트가 다를 때 엔티티 비교

영속성 컨텍스트가 다르면 동일성 비교에 실패한다.

- 동일성 : == 비교가 실패한다.
- 동등성 : equals() 비교가 같다. 단 equals()를 구현해야 한다. 보통 비즈니스 키로 구현
- 데이터베이스 동등성 : @Id인 데이터베이스 식별자가 같다.

<br>
<br>

## 프록시 심화 주제

### 1. 영속성 컨텍스트와 프록시

**프록시 조회 → 원본 엔티티 조회**

영속성 컨텍스트는 프록시로 조회된 엔티티에 대해서 같은 엔티티를 찾는 요청이 오면 원본 엔티티가 아닌 처음 조회된 프록시 반환. 

프록시로 조회해도 영속성 컨텍스트는 영속 엔티티의 동일성 보장

**원본 엔티티 조회 → 프록시 조회**

프록시를 조회하더라도 원본 엔티티가 반환되므로 영속 엔티티의 동일성 보장

### 2. 프록시 타입 비교

프록시와 원본 엔티티 타입을 비교할 때는 프록시가 원본 엔티티를 상속 받아서 만들어지므로 `instanceof` 를 사용해야 함

### 3 프록시 동등성 비교

`[member.name](http://member.name)` 과 같이 프록시의 멤버변수에 직접 접근하면 null 을 반환해서 equals() 는 false.

프록시의 데이터를 조회할 때는 getter 접근자를 사용해야 eqauls() 는 true 가 된다.

### 4 상속관계와 프록시

**프록시를 부모 타입으로 조회하면 문제 발생**

프록시를 부모 타입으로 조회하면 부모 타입을 기반으로 프록시가 생성되어

- instanceof 연산을 사용할 수 없다.
- 하위 타입으로 다운캐스팅 할 수 없다.

**해결 방법**

1. JPQL로 대상 직접 조회
   - 처음부터 자식 타입을 직접 조회
2. 프록시에서 원본 엔티티 찾기
3. 기능을 위한 별도의 인터페이스 제공
4. 비지터 패턴 사용

<br>
<br>

## 성능 최적화

### 1. N+1 문제

**즉시 로딩과 N+1**

`em.find(Member.class, id)` 메서드로 조회시 조인을 사용하여 한 번의 SQL로 회원과 주문정보를 함께 조회

```sql
SELECT M.*, O.* 
FROM
		MEMBER M
	OUTER JOIN ORDERS O ON M.ID=O.MEMBER_ID
```

JPQL로 `select m from Member m` 을 실행시킬 때 문제 발생. 회원과 연관된 주문을 조회하는 N 번의 쿼리 실행 `select * from orders where member_id=1 ...`

**지연 로딩과 N+1**

연관된 컬렉션을 사용할 때 N + 1 문제 발생

**N+1 문제 해결**

1. 페치 조인 사용
2. 하이버네이트 @BatchSize : 연관된 엔티티를 조회할 때 지정한 size만큼 SQL의 IN 절을 사용해서 조회
3. 하이버네이트 @Fetch(FetchMode.SUBSELECT) : 연관된 데이터를 조회할 때 서브 쿼리를 사용

### 2. 읽기 전용 쿼리의 성능 최적화

읽기 전용의 엔티티를 영속성 컨텍스트가 관리하지 않는 것이 메모리 사용량을 줄일 수 있고, 문제도 발생하지 않음

**JPQL 쿼리 최적화**

1. 스칼라 타입으로 조회 `select o.id, o.name, o.price from Order o`

2. 읽기 전용 쿼리 힌트 사용

   ```sql
   TypeQuery<Order> query = em.createQuery("select o from Order o", Order.class);
   query.setHint("org.hibernate.readOnly", true);
   ```

3. 읽기 전용 트랜잭션 사용 `@Transactional(readOnly = true)`

   - 트랜잭션 과정은 동작하지만 영속성 컨텍스트를 플러시하지 않는다.

4. 트랜잭션 밖에서 읽기

   - 트랜잭션 없이 엔티티 조회

### 3. 배치 처리

**등록 배치**

많은 엔티티를 한 번에  등록할 때 주의할 점은 영속성 컨텍스트에 엔티티가 쌓이지 않도록 일정 단위마다 영속성 컨텍스트를 플러시하고 초기화해야 함

**수정 배치**

1. JPA 페이징 배치 처리
2. JDBC 커서 사용 (scroll 사용)
3. 하이버네이트 무상태 세션 사용
   - 영속성 컨텍스트 없이 updqte() 메소드 직접 호출

### 4. SQL 쿼리 힌트 사용

JPA는 데이터베이스 SQL 힌트 기능 제공하지 않아 하이버네이트를 직접 사용하여 데이터베이스 벤터에게 제공하는 SQL 힌트를 사용 

### 5. 트랜잭션을 지원하는 쓰기 지연과 성능 최적화

- 트랜잭션을 지원하는 쓰기 지연 기능으로 SQL 배치 기능 사용
- JPA의 쓰기 지연 기능은 데이터베이스에 락이 걸리는 시간을 최소화해서 동시에 더 많은 트랜잭션을 처리할 수 있는 장점이 있음
