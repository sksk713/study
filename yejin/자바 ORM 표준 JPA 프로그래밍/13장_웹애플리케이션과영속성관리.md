## 트랜잭션 범위의 영속성 컨텍스트

### 1. 스프링 컨테이너의 기본 전략

트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용

- 트랜잭션이 같으면 같은 영속성 컨텍스트 사용
  - 엔티티 매니저가 달라도 같은 영속성 컨텍스트 사용
- 트랜잭션이 다르면 다른 영속성 컨텍스트 사용
  - 여러 스레드에서 동시에 요청이 와서 같은 엔티티 매니저를 사용해도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다름
  - 멀티스레드 상황에 안전

<br>
<br>

## 준영속 상태와 지연 로딩

- 트랜잭션은 보통 서비스 계층에서 시작하고 끝남. 트랜잭션이 종료되면서 영속성 컨텍스트도 함께 종료
- 프레젠테이션 계층에서 조회한 엔티티는 준영속 상태 
  ⇒ 변경 감지, 지연 로딩 동작하지 않음

### 1. 준영속 상태와 변경 감지

- 변경 감지 기능은 비즈니스 로직(서비스 계층에서 존재)을 수행하면서 발생
- 프레젠테이션 계층에서 데이터를 보여주는 데 집중, 데이터를 변경은 서비스 계층에서

<br>

### 2. 준영속 상태와 지연 로딩

- 프레젠테이션 계층에서 연관된 엔티티를 조회할 때 프록시 객체 조회(초기화) 시도
- 준영속 상태에서 지연 로딩 시도 하면 예외 발생

**해결 방법**
1. 뷰가 필요한 엔티티를 미리 로딩해주는 방법
   1. 글로벌 페치 전략 즉시 로딩으로 변경
      - 문제 : 사용하지 않는 엔티티 로딩, N + 1 문제 발생
   2. JPQL 페치 조인 사용
      - 문제 : 프레젠테이션 계층에 맞춘 리포지토리 메소드 증가
   3. 서비스 계층에서 프록시 강제 초기화
      - 문제 : 프레젠테이션 계층에서 필요한 엔티티에 따라 서비스 계층 로직 변경(초기화 코드 추가)
   4. FACADE 계층 추가
      - 프레젠테이션 계층과 서비스 계층 사이에 FACADE 계층을 두어 프록시 초기화 담당
      - 문제 : 계층 추가로 인해 더 많은 코드 작성
2. OSIV(Open Session In View)를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법 
   - 영속성 컨텍스트를 뷰까지 열어둠
   - 영속성 컨텍스트는 트랜잭션 범위 안에서 엔티티 조회 및 수정, 트랜잭션 범위 밖에서는 엔티티 조회만 가능
   - **`스프링 OSIV`**
      - 영속성 컨텍스트는 요청이 들어올 때 생성되고 요청이 끝날 때 종료. 트랜잭션은 비즈니스 로직이 실행 될 때만 생존.
