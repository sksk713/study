**`collect`** ë¥¼ ì‚¬ìš©í•˜ì—¬ ë‹¤ì–‘í•œ ìš”ì†Œ ëˆ„ì  ë°©ì‹ì„ ì¸ìˆ˜ë¡œ ë°›ì•„ì„œ ìŠ¤íŠ¸ë¦¼ì„ ìµœì¢… ê²°ê³¼ë¡œ ë„ì¶œí•˜ëŠ” **ë¦¬ë“€ì‹± ì—°ì‚°**ì— ëŒ€í•´ ì•Œì•„ë´…ì‹œë‹¤. 
*(ë‹¤ì–‘í•œ ìš”ì†Œ ëˆ„ì  ë°©ì‹ì€ Collector ì¸í„°í˜ì´ìŠ¤ì— ì •ì˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤.)*

```java
// í†µí™”ë³„ë¡œ íŠ¸ëœì­ì…˜ì„ ê·¸ë£¹í™”í•œ ì½”ë“œ (ëª…ë ¹í˜• ë²„ì „)
Map<Currency, List<Transaction>> transactionsByCurrencies = new HashMap<>();

for (Transaction transaction : transactions) {
	Currency currency = transaction.getCurrency();
	List<Transaction> transactionsForCurrency = transactionsByCurrencies.get(currency);
	if (transactionsForCurrency == null) {
		transactionsForCurrency = new ArrayList();
		transactionsByCurrencies.put(currency, transactionsForCurrency);
	}
	transactionsForCurrency.add(transaction);
}
```
<br>

ìœ„ì˜ ì½”ë“œë¥¼ Streamì„ ì‚¬ìš©í•˜ì—¬ ì»¬ë ‰í„° íŒŒë¼ë¯¸í„°ë¥¼ collect ë©”ì„œë“œì— ì „ë‹¬í•¨ì„ì¨ ì—°ì‚°ì„ ê°„ê²°í•˜ê²Œ êµ¬í˜„í•´ë´…ì‹œë‹¤.

```java
Map<Currency, List<Transaction>> transactionsByCurrencies = transactions.stream().**collect(Collectors.groupingBy(Transaction::getCurrency))**;
```
---

<br>
<br>

## 1. ì»¬ë ‰í„°ë€ ë¬´ì—‡ì¸ê°€?

**ì»¬ë ‰í„°**ëŠ” Stream.collect ë©”ì„œë“œì˜ ì¸ìˆ˜ì…ë‹ˆë‹¤.

ìœ„ì˜ ì˜ˆì œì—ì„œ ì»¬ë ‰í„°ì¸ groupingBy(ë¥¼ ì´ìš©í•´ì„œ â€˜ê° í‚¤(í†µí™”) ë²„í‚·ê³¼ ê° í‚¤ ë²„í‚·ì— ëŒ€ì‘í•˜ëŠ” ìš”ì†Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ê°’ìœ¼ë¡œ í¬í•¨í•˜ëŠ” Mapì„ ë§Œë“¤ì–´ë¼â€™ ë¼ëŠ” ë™ì‘ì„ ìˆ˜í–‰í–ˆìŠµë‹ˆë‹¤.

ë‹¤ìˆ˜ì¤€(multilevel)ìœ¼ë¡œ ê·¸ë£¹í™”ë¥¼ ìˆ˜í–‰í•  ë•Œ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì—ì„œ í•„ìš”í•œ ì»¬ë ‰í„°ë¥¼ ì‰½ê²Œ ì¶”ê°€í•¨ìœ¼ë¡œì¨ ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì„ í–¥ìƒì‹œí‚¬ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<br>

### 1-1.  ê³ ê¸‰ ë¦¬ë“€ì‹± ê¸°ëŠ¥ì„ ìˆ˜í–‰í•˜ëŠ” ì»¬ë ‰í„°

collectì—ì„œëŠ” ë¦¬ë“€ì‹± ì—°ì‚°ì„ ì´ìš©í•´ì„œ ìŠ¤íŠ¸ë¦¼ì˜ ê° ìš”ì†Œë¥¼ ë°©ë¬¸í•˜ë©´ì„œ ì»¬ë ‰í„°ê°€ ì‘ì—…ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤. ë³´í†µ í•¨ìˆ˜ë¥¼ ìš”ì†Œë¡œ ë³€í™˜í•  ë•Œ*(ë³´í†µ `toList`ì²˜ëŸ¼ ë°ì´í„° ìì²´ë¥¼ ë³€í™˜í•˜ëŠ” ê²ƒë³´ë‹¤ ë°ì´í„° ì €ì¥ êµ¬ì¡°ë¥¼ ë³€í™˜í•©ë‹ˆë‹¤)*ëŠ” ì»¬ë ‰í„°ë¥¼ ì ìš©í•˜ë©° ìµœì¢… ê²°ê³¼ë¥¼ ì €ì¥í•˜ëŠ” ìë£Œêµ¬ì¡°ì— ê°’ì„ ëˆ„ì í•©ë‹ˆë‹¤.

> ğŸ’¡ **Collectors ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤**ëŠ” ìì£¼ ì‚¬ìš©í•˜ëŠ” ì»¬ë ‰í„° ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì†ì‰½ê²Œ ìƒì„±í•  ìˆ˜ ìˆëŠ” **ì •ì  íŒ©í† ë¦¬ ë©”ì„œë“œ**ë¥¼ ì œê³µí•©ë‹ˆë‹¤.


```java
List<Transaction> transactions = transactionStream.collect(Collectors.toList());
```

<br>

### 1-2. ë¯¸ë¦¬ ì •ì˜ëœ ì»¬ë ‰í„°

Collectors í´ë˜ìŠ¤ì—ì„œëŠ” ë¯¸ë¦¬ ì •ì˜ëœ ì»¬ë ‰í„°, íŒ©í† ë¦¬ ë©”ì„œë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤.

**Collectorsì—ì„œ ì œê³µí•˜ëŠ” ë©”ì„œë“œì˜ ê¸°ëŠ¥**

- ìŠ¤íŠ¸ë¦¼ ìš”ì†Œë¥¼ í•˜ë‚˜ì˜ ê°’ìœ¼ë¡œ **ë¦¬ë“€ìŠ¤í•˜ê³  ìš”ì•½**
    - ë‹¤ì–‘í•œ ê³„ì‚°ì„ ìˆ˜í–‰í•  ë•Œ í™œìš©
- **ìš”ì†Œ ê·¸ë£¹í™”**
    - ë‹¤ìˆ˜ì¤€ìœ¼ë¡œ ê·¸ë£¹í™”í•˜ê±°ë‚˜ ê°ê°ì˜ ê²°ê³¼ ì„œë¸Œê·¸ë£¹ì— ì¶”ê°€ë¡œ ë¦¬ë“€ì‹± ì—°ì‚°ì„ ì ìš©í•  ìˆ˜ ìˆë„ë¡ ë‹¤ì–‘í•œ ì»¬ë ‰í„° ì¡°í•©
- **ìš”ì†Œ ë¶„í• **

<br>
<br>

## 2. ë¦¬ë“€ì‹±ê³¼ ìš”ì•½ (reducing, â€¦)

ì»¬ë ‰í„°ë¡œ ìŠ¤íŠ¸ë¦¼ì˜ ëª¨ë“  í•­ëª©ì„ í•˜ë‚˜ì˜ ê²°ê³¼ë¡œ í•©ì¹  ìˆ˜ ìˆìŠµë‹ˆë‹¤. íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•˜ëŠ” **ë‹¤ìˆ˜ì¤€ ë§µ** ë˜ëŠ” **ë‹¨ìˆœí•œ ì •ìˆ˜** ë“± ë‹¤ì–‘í•œ í˜•ì‹ìœ¼ë¡œ ê²°ê³¼ê°€ ë„ì¶œë©ë‹ˆë‹¤. ë‹¤ì–‘í•œ ê³„ì‚°ì„ ìˆ˜í–‰í•  ë•Œ ìœ ìš©í•˜ê²Œ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<br>

### 2-1. ìŠ¤íŠ¸ë¦¼ê°’ì—ì„œ ìµœëŒ“ê°’ê³¼ ìµœì†Ÿê°’ ê²€ìƒ‰

- **`Collectors.maxBy`** : ìŠ¤íŠ¸ë¦¼ì˜ ìµœëŒ“ê°’ì„ ê°€ì§„ ìš”ì†Œë¥¼ ìƒì‚°í•˜ëŠ” ì»¬ë ‰í„°
- **`Collectors.minBy`** : ìŠ¤íŠ¸ë¦¼ì˜ ìµœì†Ÿê°’ì„ ê°€ì§„ ìš”ì†Œë¥¼ ìƒì‚°í•˜ëŠ” ì»¬ë ‰í„°

```java
Comparator<Dish> dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);

Optional<Dish> mostCalorieDish = menu.stream().collect(maxBy(dishCaloriesComparator)));
```
<br>

### 2-2. ìš”ì•½ ì—°ì‚°

** ìš”ì•½ ì—°ì‚° **

ê°ì²´ì˜ ìˆ«ì í•„ë“œì˜ í•©ê²Œë‚˜ í‰ê·  ë“±ì„ ë°˜í™˜í•˜ëŠ” ì—°ì‚°

- **`Collectors.summingInt`** : ê°ì²´ë¥¼ intë¡œ ë§¤í•‘í•˜ëŠ” í•¨ìˆ˜ë¥¼ ì¸ìˆ˜ë¡œ ë°›ì•„ ê°ì²´ë¥¼ intë¡œ ë§¤í•‘í•œ ì»¬ë ‰í„° ë°˜í™˜
    
    ```java
    int totalCalories = menu.stream().collect(**summingInt(Dish::getCalories)**);
    ```
    
- **`Collectors.averagingInt**` : ìˆ«ì ì§‘í•©ì˜ í‰ê·  ê³„ì‚°
    
    ```java
    double avgCalories = menu.stream().collect(averagingInt(Dish::getCalories));
    ```
    
- **`Collectors.summarizingInt`** : ìš”ì†Œ ìˆ˜, í•©ê³„, í‰ê· , ìµœëŒ“ê°’, ìµœì†Ÿê°’ ë“± ê³„ì‚°
    
    ```java
    IntSummaryStatistics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories));
    
    // IntSummaryStatistics{count=9, sum=4300, min=120, average=477.777778, max=800}
    ```
    
<br>

### 2-3. ë¬¸ìì—´ ì—°ê²°

**`Collectors.joining`** íŒ©í† ë¦¬ ë©”ì„œë“œë¥¼ ì´ìš©í•´ì„œ ìŠ¤íŠ¸ë¦¼ì˜ ê° ê°ì²´ì— toString ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ì„œ ì¶”ì¶œí•œ ëª¨ë“  ë¬¸ìì—´ì„ í•˜ë‚˜ì˜ ë¬¸ìì—´ë¡œ ì—°ê²°í•´ì„œ ë°˜í™˜í•©ë‹ˆë‹¤.

joining ë©”ì„œë“œëŠ” ë‚´ë¶€ì ìœ¼ë¡œ StringBuilderë¥¼ ì´ìš©í•´ì„œ ë¬¸ìì—´ì„ í•˜ë‚˜ë¡œ ë§Œë“­ë‹ˆë‹¤.

```java
String shortMenu = menu.stream().map(Dish::getName).collect(joining());
// porkbeefchickenfrench friesriceseason fruitpizzaprawnssalmon

// ì—°ê²°ëœ ë‘ ìš”ì†Œ ì‚¬ì´ì— êµ¬ë¶„ ë¬¸ìì—´ ì‚¬ìš©
String shortMenu = menu.stream().map(Dish::getName).collect(joining(", "));
// pork, beef, chicken, french fries, rice, season, fruit, pizza, prawns, salmon
```
<br>

### 2-4. ë²”ìš© ë¦¬ë“€ì‹± ìš”ì•½ ì—°ì‚°

ëª¨ë“  ì»¬ë ‰í„°ëŠ” reducing íŒ©í† ë¦¬ ë©”ì„œë“œ *(ë²”ìš© Collectors.reducing)* ë¡œ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë²”ìš© íŒ©í† ë¦¬ ë©”ì„œë“œ ëŒ€ì‹  íŠ¹í™”ëœ ì»¬ë ‰í„° *(ìœ„ì˜ ì˜ˆì‹œ: Collectors.maxBy,â€¦)* ë¥¼ ì‚¬ìš©í•œ ì´ìœ ëŠ” í”„ë¡œê·¸ë˜ë°ì  í¸ì˜ì„± ë•Œë¬¸ì…ë‹ˆë‹¤.

```java
// reducing ë©”ì„œë“œë¡œ ë§Œë“¤ì–´ì§„ ì»¬ë ‰í„°ë¡œ ë©”ë‰´ì˜ ëª¨ë“  ì¹¼ë¡œë¦¬ í•©ê³„ ê³„ì‚°
int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, (i, j) -> i + j));
```

**reducing íŒ©í† ë¦¬ ë©”ì„œë“œ ì¸ìˆ˜**

- ì²« ë²ˆì§¸ ì¸ìˆ˜ : ë¦¬ë“€ì‹± ì—°ì‚°ì˜ ì‹œì‘ê°’ì´ê±°ë‚˜ ìŠ¤íŠ¸ë¦¼ì— ì¸ìˆ˜ê°€ ì—†ì„ ë•Œì˜ ë°˜í™˜ê°’
- ë‘ ë²ˆì§¸ ì¸ìˆ˜ : ë³€í™˜ í•¨ìˆ˜
- ì„¸ ë²ˆì§¸ ì¸ìˆ˜ : BinaryOperator

>ğŸ’¡ **Stream ì¸í„°í˜ì´ìŠ¤ì˜ collectì™€ reduce ë©”ì„œë“œì˜ ì°¨ì´**  
>collect : ë„ì¶œí•˜ë ¤ëŠ” ê²°ê³¼ë¥¼ ëˆ„ì í•˜ëŠ” ì»¨í…Œì´ë„ˆë¥¼ ë°”ê¾¸ë„ë¡ ì„¤ê³„ëœ ë©”ì„œë“œ  
>reduce : ë‘ ê°’ì„ í•˜ë‚˜ë¡œ ë„ì¶œí•˜ëŠ” ë¶ˆë³€í˜• ì—°ì‚°


>ğŸ’¡ **ì œë„¤ë¦­ ì™€ì¼ë“œì¹´ë“œ â€˜?â€™ ì‚¬ìš©ë²•**    
> public static <T> Collector<T, ?, Long> counting() {     
>    return reducing(0L, e â†’ 1L, Long:sum);     
> }
> 
>? ëŠ” ì»¬ë ‰í„°ì˜ ëˆ„ì ì í˜•ì‹ì´ ì•Œë ¤ì§€ì§€ ì•Šì•˜ìŒì„, ì¦‰ ëˆ„ì ìì˜ í˜•ì‹ì´ ììœ ë¡œì›€ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.


### ì»¬ë ‰ì…˜ í”„ë ˆì„ì›Œí¬ ìœ ì—°ì„± : ê°™ì€ ì—°ì‚°ë„ ë‹¤ì–‘í•œ ë°©ì‹ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.

ë‹¤ìŒê³¼ ê°™ì´ í•©ê³„ë¥¼ êµ¬í•˜ëŠ” ë‹¤ì–‘í•œ ë°©ë²•ì´ ì¡´ì¬í•©ë‹ˆë‹¤.

```java
int totalCalories1 = menu.stream().collect(Collectors.reducing(0, Dish::getCalories, Integer::sum));

Optional<Integer> totalCalories2 = menu.stream().map(Dish::getCalories).reduce(Integer::sum);

int totalCalories3 = menu.stream().mapToInt(Dish::getCalories).sum();
```

<br>
<br>

## 3. ê·¸ë£¹í™” (groupingBy)

ë°ì´í„° ì§‘í•©ì„ í•˜ë‚˜ ì´ìƒì˜ íŠ¹ì„±ìœ¼ë¡œ ë¶„ë¥˜í•´ì„œ ê·¸ë£¹í™”í•˜ëŠ” ì—°ì‚°ë„ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë§ì´ ìˆ˜í–‰ë˜ëŠ” ì‘ì—…ì…ë‹ˆë‹¤. **`Collectors.groupingBy`** *(ë¶„ë¥˜ í•¨ìˆ˜: í•¨ìˆ˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìŠ¤íŠ¸ë¦¼ ê·¸ë£¹í™”)* íŒ©í† ë¦¬ ë©”ì„œë“œë¡œ ì‰½ê²Œ ê·¸ë£¹í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```java
Map<Dish.Type, List<Dish>> dishsByType = menu.stream().collect(groupingBy(Dish::getType));

// {FISH=[prawns, salmon], OTHER=[french fries, rice, season, fruit, pizza], MEAT=[pork, beef, chicken]}
```

ê·¸ë£¹í™” ì—°ì‚°ì˜ ê²°ê³¼ë¡œ ê·¸ë£¹í™” í•¨ìˆ˜ê°€ ë°˜í™˜í•˜ëŠ” í‚¤, ê° í‚¤ì— ëŒ€ì‘í•˜ëŠ” ìŠ¤íŠ¸ë¦¼ì˜ ëª¨ë“  í•­ëª© ë¦¬ìŠ¤íŠ¸ë¥¼ ê°’ìœ¼ë¡œ ê°–ëŠ” ë§µì´ ë°˜í™˜ë©ë‹ˆë‹¤.

```java
// 400ì¹¼ë¡œë¦¬ ì´í•˜ë¥¼ 'diet', 400~700ì¹¼ë¡œë¦¬ë¥¼ 'normal', 700ì¹¼ë¡œë¦¬ ì´ˆê³¼ë¥¼ 'fat' ìš”ë¦¬ë¡œ ë¶„ë¥˜
publiic enum CaloricLevel { DIET, NORMAL, FAT }

Map<CaloricLevel, List<Dish>> dishesByCaloricLevel = menu.stream().collect(
		groupingBy(dish -> {
				if (dish.getCalories() <= 400) return CaloricLevel.DIET;
				else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
				else return CaloricLevel.FAT;
		}));
```

<br>

### 3-1. ê·¸ë£¹í™”ëœ ìš”ì†Œ ì¡°ì‘

groupingBy ë©”ì„œë“œì™€ ì—°ê³„í•˜ì—¬ ìš”ì†Œë¥¼ ê·¸ë£¹í™” í•œ ë‹¤ìŒì— ê° ê²°ê³¼ ê·¸ë£¹ì˜ ìš”ì†Œë¥¼ ì¡°ì‘í•˜ëŠ” ì—°ì‚°ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

- **`filtering`** ë©”ì„œë“œëŠ” Collectors í´ë˜ìŠ¤ì˜ ì •ì  íŒ©í† ë¦¬ ë©”ì„œë“œë¡œ Predicateë¥¼ ì¸ìˆ˜ë¡œ ë°›ì•„ ê° ê·¸ë£¹ì˜ ìš”ì†Œì™€ í•„í„°ë§ëœ ìš”ì†Œë¥¼ ì¬ê·¸ë£¹í™”í•©ë‹ˆë‹¤.
    
    ```java
    Map<Dish.Type, List<Dish>> caloricDishesByType = menu.stream()
      .collect(
    		**groupingBy(
    				Dish::getType, filtering(dish -> dish.getCalories() > 500, toList())
    		)**
    	);
    ```
    

- **`mapping`** ë©”ì„œë“œëŠ” ë§¤í•‘ í•¨ìˆ˜ë¥¼ ì´ìš©í•´ ìš”ì†Œë¥¼ ë³€í™˜í•©ë‹ˆë‹¤.
    
    ```java
    // ê·¸ë£¹ì˜ ê° ìš”ë¦¬ë¥¼ ê´€ë ¨ ì´ë¦„ ëª©ë¡ìœ¼ë¡œ ë³€í™˜
    Map<Dish.Type, List<String>> dishNamesByType = menu.stream()
    	.collect(
    		**groupingBy(
    			Dish::getType, mapping(Dish::getName, toList())
    		)**
    	);
    ```
    

- **`flatMapping`** ë©”ì„œë“œ
    
    ```java
    // íƒœê·¸ ëª©ë¡
    Map<String, List<String>> dishTags = new HashMap<>();
    dishTags.put("pork", asList("greasy", "salty"));
    ...
    
    Map<Dish.Type, Set<String>> dishNamesByType = menu.stream()
    	.collect(
    		**groupingBy(
    			Dish::getType, flatMapping(dish -> dishTags.get(dish.getName()).stream(), toSet())
    		)**
    	);
    ```
    
<br>

### 3-2. ë‹¤ìˆ˜ì¤€ ê·¸ë£¹í™”

goupingBy ë©”ì„œë“œëŠ” ì¼ë°˜ì ì¸ ë¶„ë¥˜ í•¨ìˆ˜ì™€ ì»¬ë ‰í„°ë¥¼ ì¸ìˆ˜ë¡œ ë°›ìŠµë‹ˆë‹¤. ë°”ê¹¥ìª½ goupingBy ë©”ì„œë“œì— ìŠ¤í‹€ë¦¼ì˜ í•­ëª©ì„ ë¶„ë¥˜í•  ë‘ ë²ˆì§¸ ê¸°ì¤€ì„ ì •ì˜í•˜ëŠ” ë‚´ë¶€ groupingByë¥¼ ì „ë”œí•´ì„œ ë‹¤ìˆ˜ì¤€ìœ¼ë¡œ ìŠ¤íŠ¸ë¦¼ì˜ í•­ëª©ìœ¼ ê·¸ë£¹í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```java
Map<Dish.Type, Map<CaloricLevel, List<Dish>>> dishesByTypeCaloricLevel = 
      menu.stream().collect(
            groupingBy(Dish::getType,  // ì²« ë²ˆì§¸ ìˆ˜ì¤€ì˜ ë¶„ë¥˜ í•¨ìˆ˜
                  groupingBy(dish -> {  // ë‘ ë²ˆì§¸ ìˆ˜ì¤€ì˜ ë¶„ë¥˜ í•¨ìˆ˜
                      if (dish.getCalories() <= 400) {
                          return CaloricLevel.DIET;
                      } else if (dish.getCalories() <= 700) {
                          return CaloricLevel.NORMAL;
                      } else {
                          return CaloricLevel.FAT;
                      }
                  })
							)
      );

// {MEAT={DIET=[chicken], NORMAL=[beef], FAT=[pork]},
//  FISH={DIET=[prawns], NORMAL=[salmon]},
//  OTHER={DIET=[rice, seasonal fruit]. NORAML=[french fries, pizza]}}
```

 ì™¸ë¶€ ë§µì€ ì²« ë²ˆì§¸ ìˆ˜ì¤€ì˜ ë¶„ë¥˜ í•¨ìˆ˜ì—ì„œ ë¶„ë¥˜í•œ í‚¤ê°’ì„ ê°–ê³ , ë‚´ë¶€ ë§µì˜ ê°’ì€ ë‘ ë²ˆì§¸ ìˆ˜ì¤€ì˜ ë¶„ë¥˜ í•¨ìˆ˜ì˜ í‚¤ê°’ì„ ê°–ìŠµë‹ˆë‹¤.

<br>

### 3-3. ì„œë¸Œê·¸ë£¹ìœ¼ë¡œ ë°ì´í„° ìˆ˜ì§‘

groupingByë¡œ ë„˜ê²¨ì£¼ëŠ” ì»¬ë ‰í„°ëŠ” **ê°™ì€ ê·¸ë£¹ìœ¼ë¡œ ë¶„ë¥˜ëœ ëª¨ë“  ìš”ì†Œì— ë¦¬ë“€ì‹± ì‘ì—…ì„ ìˆ˜í–‰**í•©ë‹ˆë‹¤. ë˜í•œ ì»¬ë ‰í„°ì˜ í˜•ì‹ì€ ì œí•œì´ ì—†ê¸° ë•Œë¬¸ì— ë‹¤ìˆ˜ì¤€ ê·¸ë£¹í™” ì—°ì‚° ë¿ë§Œ ì•„ë‹ˆë¼ ë‹¤ì–‘í•œ ì—°ì‚°ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. 

```java
// ìš”ë¦¬ì˜ ìˆ˜ë¥¼ ì¢…ë¥˜ë³„ë¡œ ê³„ì‚°
Map<Dish.Type, Long> typesCount = menu.stream().collect(groupingBy(Dish::getType, counting()));
// {MEAT=3, FISH=2, OTHER=4}
```

**ì»¬ë ‰í„° ê²°ê³¼ë¥¼ ë‹¤ë¥¸ í˜•ì‹ì— ì ìš©í•˜ê¸°**

**`Collectors.collectingAndThen`** ë©”ì„œë“œë¡œ ì»¬ë ‰í„°ê°€ ë°˜í™˜í•œ ê²°ê³¼ë¥¼ ë‹¤ë¥¸ í˜•ì‹ìœ¼ë¡œ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```java
Map<Dish.Type, Dish> mostCaloricByType =
    menu.stream().collect(
        groupingBy(Dish::getType,  // ë¶„ë¥˜ í•¨ìˆ˜
              collectingAndThen(
                  maxBy(Comparator.comparingInt(Dish::getCalories)),  // ì»¬ë ‰í„°
                  Optional::get)  // ë³€í™˜ í•¨ìˆ˜
        )
    );
```

<br>
<br>

## 4. ë¶„í• 

ë¶„í• ì€ ë¶„í•  í•¨ìˆ˜ë¼ ë¶ˆë¦¬ëŠ” Predicateë¥¼ ë¶„ë¥˜ í•¨ìˆ˜ë¡œ ì‚¬ìš©í•˜ëŠ” **íŠ¹ìˆ˜í•œ ê·¸ë£¹í™” ê¸°ëŠ¥**ì…ë‹ˆë‹¤. ë¶„í•  í•¨ìˆ˜ì˜ ë§µ í‚¤ í˜•ì‹ì€ Booleanìœ¼ë¡œ ë‘ ê°œì˜ ê·¸ë£¹ìœ¼ë¡œ ë¶„ë¥˜í•©ë‹ˆë‹¤.

```java
Map<Boolean, List<Dish>> partitionedMenu = menu.stream().collect(partitioningBy(Dish::isVegetarian));

// {false=[pork, beef], true=[french fries, rice]}
```

<br>

### 4-1. ë¶„í• ì˜ ì¥ì 

ë¶„í• ì˜ ì¥ì ì€ ë¶„í•  í•¨ìˆ˜ê°€ ë°˜í™˜í•˜ëŠ” ì°¸, ê±°ì§“ ë‘ ê°€ì§€ ìš”ì†Œì˜ ìŠ¤íŠ¸ë¦¼ ë¦¬ìŠ¤íŠ¸ë¥¼ ëª¨ë‘ ìœ ì§€í•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤.

```java
Map<Boolean, Map<Dish.Type, List<Dish>>> vegetarianDishesByType = menu.stream().collect(
		partitioningBy(Dish::isVegetarian, // ë¶„í•  í•¨ìˆ˜
			groupingBy(Dish::getType)));  // ë‘ ë²ˆì§¸ ì»¬ë ‰í„°
```

ì»¬ë ‰í„°ë¥¼ ë‘ ë²ˆì§¸ ì¸ìˆ˜ë¡œ ì „ë‹¬í•  ìˆ˜ ìˆëŠ” ì˜¤ë²„ë¡œë“œëœ ë²„ì „ì˜ partitioningBy ë©”ì„œë“œë„ ìˆìŠµë‹ˆë‹¤.

<br>

### 4-2. ìˆ«ìë¥¼ ì†Œìˆ˜ì™€ ë¹„ì†Œìˆ˜ë¡œ ë¶„í• í•˜ê¸°

ì •ìˆ˜ nì„ ì¸ìˆ˜ë¡œ ë°›ì•„ì„œ 2ì—ì„œ nê¹Œì§€ì˜ ìì—°ìˆ˜ë¥¼ ì†Œìˆ˜ì™€ ë¹„ì†Œìˆ˜ë¡œ ë‚˜ëˆ„ëŠ” í”„ë¡œê·¸ë¨ì„ êµ¬í˜„í•´ë´…ì‹œë‹¤. 

ë¨¼ì € ì£¼ì–´ì§„ ìˆ˜ê°€ ì†Œìˆ˜ì¸ì§€ ì•„ë‹Œì§€ íŒë‹¨í•˜ëŠ” Predicateë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.

```java
public boolean isPrime(int candidate) {
		int candidateRoot = (int) Math.sqrt((double) candidate); // ì†Œìˆ˜ì˜ ëŒ€ìƒì„ ì£¼ì–´ì§„ ìˆ˜ì˜ ì œê³±ê·¼ ì´í•˜ì˜ ìˆ˜ë¡œ ì œí•œ
		return IntStream.range(2, candidateRoot)  // 2ë¶€í„° candidate ë¯¸ë§Œ ì‚¬ì´ì˜ ìì—°ìˆ˜ ìƒì„±
				.noneMatch(i -> candidate % i == 0);  // ìŠ¤íŠ¸ë¦¼ì˜ ëª¨ë“  ì •ìˆ˜ë¡œ candidateë¥¼ ë‚˜ëˆŒ ìˆ˜ ì—†ìœ¼ë©´ ì°¸ ë°˜í™˜)
```

isPrime ë©”ì„œë“œë¥¼ ì´ìš©í•˜ì—¬ partitioningBy ì»¬ë ‰í„°ë¡œ ë¦¬ë“€ìŠ¤í•´ì„œ ìˆ«ìë¥¼ ì†Œìˆ˜ì™€ ë¹„ì†Œìˆ˜ë¡œ ë¶„ë¥˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```java
public Map<Boolean, List<Integer>> partitionPrimes(int n) {
		return IntStream.rangeClosed(2, n).boxed()
										.collect(
												partitioningBy(candidate -> isPrime(candidate)));
}
```

<br>
<br>

## 5. Collector ì¸í„°í˜ì´ìŠ¤

Collector ì¸í„°í˜ì´ìŠ¤ëŠ” **ë¦¬ë“€ì‹± ì—°ì‚°(ì¦‰, ì»¤ë ‰í„°)ì„ ì–´ë–»ê²Œ êµ¬í˜„í• ì§€ ì œê³µí•˜ëŠ” ë©”ì„œë“œ ì§‘í•©**ìœ¼ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤. Collectors.toList, Collectors.groupingBy ë“±ì€ Collector ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ëŠ” ì»¬ë ‰í„°ì…ë‹ˆë‹¤.

Collector ì¸í„°í˜ì´ìŠ¤ì˜ ì‹œê·¸ë‹ˆì²˜ì™€ ë‹¤ì„¯ ê°œì˜ ë©”ì„œë“œ ì •ì˜ì…ë‹ˆë‹¤.

```java
public interface Collector<T, A, R> {
		Supplier<A> supplier();
		BiConsumer<A, T> accumulator();
		Function<A, R> finisher();
		BinaryOperator<A> combiner();;
		Set<Characteristics> characteristics();
}
```

- T : ìˆ˜ì§‘ë  ìŠ¤íŠ¸ë¦¼ í•­ëª©ì˜ ì œë„¤ë¦­ í˜•ì‹
- A : ëˆ„ì ì, ì¦‰ ìˆ˜ì§‘ ê³¼ì •ì—ì„œ ì¤‘ê°„ ê²°ê³¼ë¥¼ ëˆ„ì í•˜ëŠ” ê°ì²´ í˜•ì‹
- R : ìˆ˜ì§‘ ì—°ì‚° ê²°ê³¼ ê°ì²´ì˜ í˜•ì‹

ì˜ˆë¥¼ ë“¤ì–´ Stream<T>ì˜ ëª¨ë“  ìš”ì†Œë¥¼ List<T>ë¡œ ìˆ˜ì§‘í•˜ëŠ” ToListCollector<T>ë¼ëŠ” í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•´ ë´…ì‹œë‹¤.

`public class ToListCollector<T> implements Collector<T, List<T>, List<T>>` 

<br>

### 5-1. Collector ì¸í„°í˜ì´ìŠ¤ì˜ ë©”ì„œë“œ ì‚´í´ë³´ê¸°

- **supplier ë©”ì„œë“œ : ìƒˆë¡œìš´ ê²°ê³¼ ì»¨í…Œì´ë„ˆ ë§Œë“¤ê¸°**
    
    supplier ë©”ì„œë“œëŠ” ìˆ˜ì§‘ ê³¼ì •ì—ì„œ ë¹ˆ ëˆ„ì ì ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§Œë“œëŠ” **íŒŒë¼ë¯¸í„°ê°€ ì—†ëŠ” í•¨ìˆ˜**ì´ê³ , **ë¹ˆ ê²°ê³¼ë¡œ ì´ë£¨ì–´ì§„ Supplierë¥¼ ë°˜í™˜**í•´ì•¼ í•©ë‹ˆë‹¤. 
    
    ToListCollectorì—ì„œ supplierëŠ” ë‹¤ìŒì²˜ëŸ¼ ë¹ˆ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    
    ```java
    @Override
    public Supplier<List<T>> supplier() {
        return () -> new ArrayList<>();
    }
    ```
    
- **accumulator ë©”ì„œë“œ : ê²°ê³¼ ì»¨í…Œì´ë„ˆì— ìš”ì†Œ ì¶”ê°€í•˜ê¸°**
    
    accumulator ë©”ì„œë“œëŠ” **ë¦¬ë“€ì‹± ì—°ì‚°ì„ ìˆ˜í–‰í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë°˜í™˜**í•©ë‹ˆë‹¤. ìŠ¤íŠ¸ë¦¼ì—ì„œ në²ˆì§¸ ìš”ì†Œë¥¼ íƒìƒ‰í•  ë•Œ ë‘ ì¸ìˆ˜, ì¦‰ ëˆ„ì ì*(ìŠ¤íŠ¸ë¦¼ì˜ ì²« n-1ê°œ í•­ëª©ì„ ìˆ˜ì§‘í•œ ìƒíƒœ)*ì™€ në²ˆì§¸ ìš”ì†Œë¥¼ í•¨ìˆ˜ì— ì ìš©í•©ë‹ˆë‹¤.
    
    ```java
    @Override
    public BiConsumer<List<T>, T> accumulator() {
        return (list, item) -> list.add(item);
    }
    ```
    
- **finisher ë©”ì„œë“œ : ìµœì¢… ë³€í™˜ê°’ì„ ê²°ê³¼ ì»¨í…Œì´ë„ˆë¡œ ì ìš©í•˜ê¸°**
    
    finisher ë©”ì„œë“œëŠ” ìŠ¤íŠ¸ë¦¼ íƒìƒ‰ì„ ëë‚´ê³  **ëˆ„ì ì ê°ì²´ë¥¼ ìµœì¢… ê²°ê³¼ë¡œ ë³€í™˜**í•˜ë©´ì„œ ëˆ„ì  ê³¼ì •ì„ ëë‚¼ ë•Œ í˜¸ì¶œí•  í•¨ìˆ˜ë¥¼ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.
    
    ëˆ„ì ì ê°ì²´ê°€ ì´ë¯¸ ìµœì¢… ê²°ê³¼ì¸ ìƒí™©ì—ì„œëŠ” ë³€í™˜ ê³¼ì •ì´ í•„ìš”í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ finisher ë©”ì„œë“œëŠ” í•­ë“± í•¨ìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    
    ```java
    @Override
    public Function<List<T>, List<T>> finisher() {
        return Function.identity();
    }
    ```
    
- **combiner ë©”ì„œë“œ : ë‘ ê²°ê³¼ ì»¨í…Œì´ë„ˆ ë³‘í•©**
    
    combinerëŠ” ìŠ¤íŠ¸ë¦¼ì˜ ì„œë¡œ ë‹¤ë¥¸ ì„œë¸ŒíŒŒíŠ¸ë¥¼ **ë³‘ë ¬ë¡œ ì²˜ë¦¬í•  ë•Œ ëˆ„ì ìê°€ ì´ ê²°ê³¼ë¥¼ ì–´ë–»ê²Œ ì²˜ë¦¬í• ì§€ ì •ì˜**í•©ë‹ˆë‹¤.
    
    ```java
    @Override
    public BinaryOperator<List<T>> combiner() {
        return (list1, list2) -> {
            list1.addAll(list2);
            return list1;
        };
    }
    ```
    
- **characteristics ë©”ì„œë“œ**
    
    characteristics ë©”ì„œë“œëŠ” ì»¬ë ‰í„°ì˜ ì—°ì‚°ì„ ì •ì˜í•˜ëŠ” Characteristics í˜•ì‹ì˜ ë¶ˆë³€ ì§‘í•©ì„ ë°˜í™˜í•©ë‹ˆë‹¤. CharacteristicsëŠ” ìŠ¤íŠ¸ë¦¼ì„ ë³‘ë ¬ë¡œ ë¦¬ë“€ìŠ¤í•  ê²ƒì¸ì§€ ê·¸ë¦¬ê³  ë³‘ë ¬ë¡œ ë¦¬ë“€ìŠ¤í•œë‹¤ë©´ ì–´ë–¤ ìµœì í™”ë¥¼ ì„ íƒí•´ì•¼ í• ì§€ íŒíŠ¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
    
    - Enum í˜•ì‹ì˜ Characteristics
        - UNORDERED : ë¦¬ë“€ì‹± ê²°ê³¼ëŠ” ìŠ¤íŠ¸ë¦¼ ìš”ì†Œì˜ ë°©ë¬¸ ìˆœì„œë‚˜ ëˆ„ì  ìˆœì„œì— ì˜í–¥ì„ ë°›ì§€ ì•ŠìŒ
        - CONCURRENT : ë‹¤ì¤‘ ìŠ¤ë ˆë“œì—ì„œ accumulator í•¨ìˆ˜ë¥¼ ë™ì‹œì— í˜¸ì¶œí•  ìˆ˜ ìˆìœ¼ë©° ì´ ì»¬ë ‰í„°ëŠ” ìŠ¤íŠ¸ë¦¼ì˜ ë³‘ë ¬ ë¦¬ë“€ì‹±ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŒ
        - IDENTITY_FINISH : finisher ë©”ì„œë“œê°€ í•­ë“± í•¨ìˆ˜ì´ê³  ìƒëµë  ìˆ˜ ìˆìŒì„ ë‚˜íƒ€ëƒ„. ë˜í•œ ëˆ„ì ì Aë¥¼ ê²°ê³¼ Rë¡œ ì•ˆì „í•˜ê²Œ í˜•ë³€í™˜í•  ìˆ˜ ìˆìŒ
    
    ```java
    @Override
    public Set<Characteristics> characteristics() {
        return Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH, Characteristics.CONCURRENT));
    }
    ```
    
<br>

### 5-2. ì‘ìš©í•˜ê¸°

```java
public class ToListCollector<T> implements Collector<T, List<T>, List<T>> {

    @Override
    public Supplier<List<T>> supplier() {
        return ArrayList::new;  // ìˆ˜ì§‘ ì—°ì‚°ì˜ ì‹œë°œì 
    }

    @Override
    public BiConsumer<List<T>, T> accumulator() {
        return List::add;  // íƒìƒ‰í•œ í•­ëª©ì„ ëˆ„ì í•˜ê³  ë°”ë¡œ ëˆ„ì ìë¥¼ ê³ ì¹œë‹¤
    }

    @Override
    public BinaryOperator<List<T>> combiner() {
        return (list1, list2) -> {  // ë‘ ë²ˆì§¸ ì½˜í…ì¸ ì™€ í•©ì³ì„œ ì²« ë²ˆì§¸ ëˆ„ì ìë¥¼ ê³ ì¹œë‹¤.
            list1.addAll(list2);  // ë³€ê²½ëœ ì²« ë²ˆì§¸ ëˆ„ì ìë¥¼ ë°˜í™˜í•œë‹¤.
            return list1;
        };
    }

    @Override
    public Function<List<T>, List<T>> finisher() {
        return Function.identity();  // í•­ë“± í•¨ìˆ˜
    }

    @Override
    public Set<Characteristics> characteristics() {
        return Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH, Characteristics.CONCURRENT));  // ì»¬ë ‰í„°ì˜ í”Œë˜ê·¸ë¥¼ IDENTITY_FINISH, CONCURRENTë¡œ ì„¤ì •í•œë‹¤.
    }
}
```

**ì»¬ë ‰í„° êµ¬í˜„ì„ ë§Œë“¤ì§€ ì•Šê³ ë„ ì»¤ìŠ¤í…€ ìˆ˜ì§‘ ìˆ˜í–‰í•˜ê¸°**

Streamì€ ì„¸ í•¨ìˆ˜(ë°œí–‰, ëˆ„ì , í•©ì¹¨)ì„ ì¸ìˆ˜ë¡œ ë°›ëŠ” collect ë©”ì„œë“œë¥¼ ì˜¤ë²„ë¡œë“œí•˜ë©° ê°ê°ì˜ ë©”ì„œë“œëŠ” Collector ì¸í„°í˜ì´ìŠ¤ì˜ ë©”ì„œë“œê°€ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ì™€ ê°™ì€ ê¸°ëŠ¥ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. 

```java
List<Dish> dishes = menuStream.collect(
		ArrayList::new,  // ë°œí–‰
		List::add,  // ëˆ„ì 
		List::addAll);  // í•©ì¹¨
```

<br>
<br>

## 6. ì»¤ìŠ¤í…€ ì»¬ë ‰í„°ë¥¼ êµ¬í˜„í•´ì„œ ì„±ëŠ¥ ê°œì„ í•˜ê¸°

n ì´í•˜ì˜ ìì—°ìˆ˜ë¥¼ ì†Œìˆ˜ì™€ ë¹„ì†Œìˆ˜ë¡œ ë¶„ë¥˜í•˜ëŠ” ë©”ì„œë“œë¥¼ ê°œì„ í•´ë´…ì‹œë‹¤.

```java
public boolean isPrime(int candidate) {
		int candidateRoot = (int) Math.sqrt((double) candidate);
		return IntStream.rangeClosed(2, candidateRoot)
										.noneMatch(i -> candidate % i == 0);
}

public Map<Boolean, List<Integer>> partitionPrimes(int n) {
		return IntStream.rangeClosed(2, n).boxed()
										.collect(partitioningBy(candidate -> isPrime(candidate));
}
```

<br>

### 6-1. ì†Œìˆ˜ë¡œë§Œ ë‚˜ëˆ„ê¸°

- **1ë‹¨ê³„ : Collector í´ë˜ìŠ¤ ì‹œê·¸ë‹ˆì²˜ ì •ì˜**
    
    ```java
    public class PrimeNumbersCollector iplements Collector<Integer,  // ìŠ¤íŠ¸ë¦¼ ìš”ì†Œì˜ í˜•ì‹ 
    		Map<Boolean, List<Integer>>,  // ëˆ„ì ì í˜•ì‹
    		Map<Boolean, List<Integer>>>  // ìˆ˜ì§‘ ì—°ì‚°ì˜ ê²°ê³¼ í˜•ì‹
    ```
    
- **2ë‹¨ê³„ : ë¦¬ë“€ì‹± ì—°ì‚° êµ¬í˜„**
    - supplier ë©”ì„œë“œ : ëˆ„ì ìë¡œ ì‚¬ìš©í•  ë§µì„ ë§Œë“¤ë©´ì„œ true, false í‚¤ì™€ ë¹ˆ ë¦¬ìŠ¤íŠ¸ë¡œ ì´ˆê¸°í™”
        
        ```java
        @Override
            public Supplier<Map<Boolean, List<Integer>>> supplier() {
                return () -> new HashMap<Boolean, List<Integer>>() { {
                    put(true, new ArrayList<>());
                    put(false, new ArrayList<>());
                }};
            }
        ```
        
    - accumulator ë©”ì„œë“œ : isPrimeì˜ í˜¸ì¶œ ê²°ê³¼ë¡œ ì†Œìˆ˜ ë¦¬ìŠ¤íŠ¸ ë˜ëŠ” ë¹„ì†Œìˆ˜ ë¦¬ìŠ¤íŠ¸ ì¤‘ ì•Œë§ì€ ë¦¬ìŠ¤íŠ¸ë¡œ candidate ì¶”ê°€
        
        ```java
        @Override
        public BiConsumer<Map<Boolean, List<Integer>>, Integer> accumulator() {
            return (Map<Boolean, List<Integer>> acc, Integer candidate) -> {
                acc.get(isPrime(acc.get(true), candidate))
                        .add(candidate);
            };
        }
        ```
        
- **3ë‹¨ê³„ : ë³‘ë ¬ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” ì»¬ë ‰í„° ë§Œë“¤ê¸°(ê°€ëŠ¥í•˜ë‹¤ë©´)**
    - combiner ë©”ì„œë“œ : ì²« ë²ˆì§¸ ë§µì— ë‘ ë²ˆì§¸ ë§µì„ ì¶”ê°€*(ì•Œê³ ë¦¬ì¦˜ì´ ìˆœì°¨ì ì´ì–´ì„œ ì‹¤ì œë¡œ ë³‘ë ¬ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ)*
        
        ```java
        @Override
        public BinaryOperator<Map<Boolean, List<Integer>>> combiner() {
            return (Map<Boolean, List<Integer>> map1, Map<Boolean, List<Integer>> map2) -> {
                map1.get(true).addAll(map2.get(true));
                map1.get(false).addAll(map2.get(false));
                return map1;
            };
        }
        ```
        
- **4ë‹¨ê³„ : finisher ë©”ì„œë“œì™€ ì»¬ë ‰í„°ì˜ characteristics ë©”ì„œë“œ**
    - finisher ë©”ì„œë“œ : accumulatorì˜ í˜•ì‹ì˜ ì»¬ë ‰í„° ê²°ê³¼ í˜•ì‹ê³¼ ê°™ìœ¼ë¯€ë¡œ í•­ë“± í•¨ìˆ˜ ë°˜í™˜
        
        ```java
        @Override
        public Function<Map<Boolean, List<Integer>>, Map<Boolean, List<Integer>>> finisher() {
            return Function.identity();
        }
        ```
        
    - characteristics ë©”ì„œë“œ
        
        ```java
        @Override
        public Set<Characteristics> characteristics() {
            return Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH));
        }
        ```
        

**ì „ì²´ì½”ë“œ**

```java
public class PrimeNumbersCollector implements Collector<Integer, Map<Boolean, List<Integer>>, Map<Boolean, List<Integer>>> {
    @Override
    public Supplier<Map<Boolean, List<Integer>>> supplier() {
        return () -> new HashMap<Boolean, List<Integer>>() { {
            put(true, new ArrayList<>());
            put(false, new ArrayList<>());
        }};
    }

    @Override
    public BiConsumer<Map<Boolean, List<Integer>>, Integer> accumulator() {
        return (Map<Boolean, List<Integer>> acc, Integer candidate) -> {
            acc.get(isPrime(acc.get(true), candidate))
                    .add(candidate);
        };
    }

    @Override
    public BinaryOperator<Map<Boolean, List<Integer>>> combiner() {
        return (Map<Boolean, List<Integer>> map1, Map<Boolean, List<Integer>> map2) -> {
            map1.get(true).addAll(map2.get(true));
            map1.get(false).addAll(map2.get(false));
            return map1;
        };
    }

    @Override
    public Function<Map<Boolean, List<Integer>>, Map<Boolean, List<Integer>>> finisher() {
        return Function.identity();
    }

    @Override
    public Set<Characteristics> characteristics() {
        return Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH));
    }

    public static boolean isPrime(List<Integer> primes, int candidate) {
        int candidateRoot = (int) Math.sqrt(candidate);
        return primes.stream()
                .takeWhile(i -> i <= candidateRoot)
                .noneMatch(i -> candidate % i == 0);
    }
}
```

```java
public Map<Boolean, List<Integer>> partitionPrimesWithCustomCollector(int n) {
		return IntStream.rangeClosed(2, n).boxed()
					.collect(new PrimeNumbersCollector());
}
```

ë‹¤ìŒê³¼ ê°™ì´ ì»¤ìŠ¤í…€ ì»¬ë ‰í„°ë¡œ êµì²´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
