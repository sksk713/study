# 트랜잭션과 락
---
트랜잭션은 ACID를 보장해야 한다. 이미 아는 개념이므로 패스

이 중에 격리성을 완벽히 보장하려면 트랜잭션을 거의 차례대로 실행해야 한다. 이런 경우 `동시성`이 매우 나빠질 수 있다.

격리 수준에는 4가지 단계가 존재한다.

1. READ UNCOMMITTED
2. READ COMMITTED
3. REPEATABLE READ
4. SERIALIZABLE

> 격리 수준이 낮을 수록 동시성은 증가하지만, 다양한 문제들이 발생하는데 대표적으로 `Dirty READ`, `NON-REPEATABLE READ`, `PHANTOM READ`이 있다.

<br></br>

# 낙관적 락과 비관적 락
---
개념만 알고 넘어가자

낙관적 락은 트랜잭션 대부분은 충돌이 발생하지 않는다고 가정하는 것을 말하고, 비관적 락은 트랜잭션의 충돌이 발생한다고 가정을 하고 락을 거는 것을 말한다.
- 낙관적 락: 애플리케이션이 제공하는 락
- 비관적 락: 데이터베이스 제공하는 락

<br></br>

# 2차 캐시
---
네트워크를 통해 데이터베이스에 접근하는 시간 비용은 애플리케이션 서버에서 내부 메모리에 접근하는 시간보다 훨씬 비싸다. 따라서 조회한 데이터를 캐시에 넣어두면 시간을 단축시킬 수 있다.

1차 캐시도 영속성 컨텍스트 내부에 존재하지만 이것은 트랜잭션이 종료되는 순간 사라지므로 유효시간이 굉장히 짧다. 여기서 1차캐시에서 DB를 뒤지기 전에, 2차 캐시를 적용할 수 있다.
- 2차 캐시는 애플리케이션 범위의 캐시이므로 애플리케이션이 종료될 때까지 유효하다.

![](image/orm11.png)

![](image/orm12.png)

2차 캐시의 특징은 3가지가 존재한다.
1. 2차 캐시는 영속성 유닛 범위의 캐시다.
2. 캐시한 객체를 직접 반환하지 않고 복사본을 만들어서 반환한다. 그대로 반환하면 동시에 수정하는 문제가 발생할 수 있기 떄문이다.
3. 기본 키를 기준으로 캐시하지만 동일성 보장은 1차 캐시에서 하는 것이기 때문에 영속성 컨텍스트가 다르다면 동일성 보장이 안된다.

<br></br>

# JPA 2차 캐시 기능
---
```java
@Cacheable
@Entity
public class Member {

    @Id
    @GeneratedValue
    private Long id;
    ~~~
}
```

간단하게 읽어봐도 될 거 같다.

`JPA에서도 2차 캐시를 지원하지만 Spring에서 지원하는 2차 캐시를 사용하도록 하자.`

[📗 Spring.io Cache Abstraction](https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#cache)