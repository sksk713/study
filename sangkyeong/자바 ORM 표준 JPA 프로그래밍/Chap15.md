# 예외 처리
---
JPA의 표준 예외들은 `javax.persistence.PersistenceException`의 자식 클래스이며, 이 예외 클래스는 `RuntimeException`의 자식이다.
- 따라서 JPA 에외는 모두 언체크 예외다. 언체크 예외는 Runtime중에 발생하는 에러로 NPE등이 있다.

여기에는 트랜잭션 롤백을 표시하는 예외와 표시하지 않는 예외가 있는데, 롤백을 표시하는 예외는 무조건 롤백(복구)되면 안된다. 이때 `RollbackException`이 발생한다.

<br></br>

# 스프링 프레임워크의 JPA 예외 변환
---
서비스 계층에서 데이터 접근 계층에 직접 의존하는 것은 좋은 설계가 아닌 것처럼, 예외도 마찬가지다. 따라서 스프링 프레임워크는 데이터 접근 계층에 대한 예외를 추상화해서 개발자에게 제공한다.

<br></br>

# 트랜잭션 롤백 시 주의사항
---
롤백이 된다는 것은 데이터베이스 데이터는 원래대로 복구되지만, 영속성 컨텍스트에 수정된 상태로 객체는 남아있게 된다. 따라서 롤백이 되면 영속성 컨텍스트를 초기화 한 다음 사용해야 한다.

앞선 주제에서 얘기했던 트랜잭션당 영속성 컨텍스트 전략은 문제가 발생하면 트랜잭션 AOP 종료 시점에 트랜잭션을 롤백하면서 영속성 컨텍스트도 종료하여 문제가 발생하지 않는다. 하지만 OSIV처럼 영속성 컨텍스트의 범위가 넓어지면 문제가 발생한다. 이때 다른 트랜잭션에서 영속성 컨텍스트를 그대로 사용할 수 있기 때문에 초기화가 필요하다.

# 엔티티 비교
> 영속성 컨텍스트 내부에는 엔티티 인스턴스를 보관하기 위한 1차 캐시가 존재한다. 이 캐시는 영속성 컨텍스트 생명주기와 동일하다.

애플리케이션 수준의 반복 가능한 읽기가 가능하여 같은 영속성 컨텍스트에서 엔티티를 조회하면 항상 같은 엔티티 인스턴스를 반환한다.

<br></br>

# 영속성 컨텍스트와 프록시
---
영속성 컨텍스는는 자신이 관리하는 영속 엔티티의 동일성을 보장한다. 그러면 `프록시`로 조회한 엔티티도 동일성을 보장할까?

```java
@Test
public void test() {

    Member refMember = em.getReference(Member.class, "member1");
    Member findMember = em.find(Member.class, "member1");
}
```

위의 코드에서 조회한 refMember와 findMember는 동일성이 보장된다.
- 여기서 중요한 것은 find메소드로 부른 객체는 원본 엔티티 객체가 아니라 처음에 호출한 프록시 객체가 반환된다.

둘의 호출 순서가 바뀌면 영속성 컨텍스트에 등록이 되므로 둘다 원본 엔티티가 반환되어 동일성이 보장된다.

<br></br>

# 프록시 객체 타입 비교
---
프록시 객체 타입비교 할때 주의할 점은 `==`연산자가 아니라 `instanceof`를 사용해야 한다. 왜냐하면 프록시 객체는 원본 객체를 상속받는 자식 타입이기 때문이다.

<br></br>

# 성능 최적화
---
N + 1문제는 `페치 조인`이나 `@BatchSize`로 해결하자.

<br></br>

# 읽기 전용 쿼리 최적화
---
수정할 필요 없이 딱 한번만 불러오면 되는 페이지가 있으면 엔티티를 조회하지말고 스칼라 타입으로 조회하자.
- 스칼라 타입은 엔티티가 아닌 모든 필드의 값을 조회하는 것으로 영속성 컨텍스트에 저장되지 않아 메모리를 절약할 수 있다.

<br></br>

# 읽기 전용 트랜잭션 사용
---
`@Transactional(readOnly = true)` 애노테이션을 사용하면 트랜잭션을 커밋해도 영속성 컨텍스트 플러시가 발생하지 않으므로 조회 외의 작업들이 실행되지 않는다.
- 트랜잭션이 없이 실행될 때도, 플러시를 호출하지 않는다.

<br></br>

# 배치 처리
---
배치는 일반적으로 수많은 데이터를 한번에 등록하거나 수정을 한다.

- 등록을 할 때, 영속성 컨텍스트를 초기화해주는 작업이 필요하다.
- 수정을 할 때, 등록보다 수많은 데이터를 조회하므로 한번에 메모리에 올려두지 못한다. 따라서 페이징을 사용해서 진행하자.
