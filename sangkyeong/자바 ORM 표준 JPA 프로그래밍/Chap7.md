# 상속 관계 매핑
---
RDB는 상속이라는 개념이 없기 때문에 ORM에서는 `슈퍼타입 서브타입 관계`라는 모델링 기법을 사용한다.

해당 기법에는 총 3가지 방법이 존재한다.

1. 각각 테이블로 변환(조인 전략)
서브타입 모델들을 모두 테이블로 만들어서 조인을 사용해서 조회한다.
2. 통합 테이블로 변환(단일 테이블 전략)
테이블을 하나로 통합해서 사용한다.
3. 서브타입 테이블로 변환(구현 클래스마다 테이블 전략)

<br>

# 조인 전략
---
부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략이다. 테이블은 타입의 개념이 없기 때문에 타입을 구분하는 컬럼을 추가로 사용해야 한다.

장점
- 테이블이 정규화된다.
- 외래 키 참조 무결성 제약조건 활용 가능
- 저장공간을 효율적으로 사용

단점
- 조인이 많이 사용되어 성능 저하
- 조회 쿼리 복잡
- 데이터 등록 시, Insert 쿼리 두번 발생

<br>

# 단일 테이블 전략
---
단일 테이블 전략은 구분 컬럼을 사용하여 모든 컬럼을 하나에 테이블에 다 넣는 방법이다. 따라서 예를 들면, 영화 테이블이 아닐 경우에 영화 테이블 외의 컬럼들엔 null값이 매핑된다.

장점
- 조인이 필요가 없어서 조회 성능이 빠르고 쿼리가 단순함

단점
- 컬럼들은 null을 허용해야 하고, 테이블이 과도하게 커질 수 있어서 오히려 조회 성능이 떨어질 수도 있음

<br>

# 구현 클래스마다 테이블 전략
---
사용하지 말자.

<br>

# @MappedSuperclass
---
이 애노테이션을 사용해서 부모 클래스는 테이블과 매핑하지 않고 자식 클래스에게 매핑 정보만 제공한다.
- 추상 클래스와 비슷함.

<br>

# 식별과 비식별 관계
---
식별 관계는 부모 테이블의 기본 키를 내려받아, 자식 테이블의 기본 키 + 외래 키로 사용하는 관계를 말한다.

비식별 관계는 부모 테이블의 기본 키를 받지만, 자식 테이블의 기본 키와는 상관없이 외래 키로만 사용하는 것을 말한다.

<br>

# 복합 키: 비식별 관계 매핑
---
복합 키는 둘 이상의 컬럼으로 이루어진 키를 말하는데 식별 자를 두개이상 사용하기 위해서는 별도로 식별자 클래스를 만들어야 한다.
- 영속성 컨텍스트에 엔티티를 보관할 때, 식별자를 사용하는데 식별자를 구분하기 위해 equals와 hashCode를 사용해서 동등성 비교를 하기 때문에 직접 구현해야 한다.

<br>

# @IdClass
---
JPA가 복합 키를 지원하기 위한 방법 중 하나로, 관계형 데이터베이스 관점에서 지향하는 방법이다. 사용 방법은 부모 클래스에 식별자 클래스의 이름을 선언해주면 된다.

@IdClass를 사용하기 위해서는 몇 가지 조건이 필요하다.
1. Serializable 인터페이스 구현
2. equals, hashCode 구현
3. 기본 생성자 필요
4. 식별자 클래스는 public

<br>

# @EmbeddedId
---
복합 키 지원하기 위한 방법으로, 객체지향적인 관점에서 지향하는 방법이다. 

```java

@Entity
public class Parent {

    @EmbeddedId
    public class Parent {

        @EmbeddedId
        private ParentId id;

        private String name;
    }
}

@Embeddable
public class ParentId implements Serializable {

    @Column(name = "PARENT_ID1")
    private String id1;

    @Column(name = "PARENT_ID2")
    private String id2;

}
```

@EmbeddedId 조건
1. @Embeddable 어노테이션 필수
2. Serializable 인터페이스 구현
3. equals, hashCode 구현
4. 기본 생성자 필요
5. 식별자 클래스 public